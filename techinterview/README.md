# 주요 구현 사항 정리

## 1. 아키텍처 & 설계 패턴
- **계층형 아키텍처**: `Controller → Service → Repository`
- **도메인 주도 설계 (DDD)**: 엔티티에 비즈니스 로직 포함
- **이벤트 기반 아키텍처**: 도메인 이벤트와 비동기 처리
- **팩토리 패턴**: 엔티티 생성 메서드 적용
- **전략 패턴**: 다양한 캐싱 전략 선택 적용

---

## 2. 핵심 기능
- ✅ **JWT 기반 인증/인가**
    - Access Token + Refresh Token
    - Refresh Token은 **Redis 저장**
- ✅ **게시판 CRUD + 댓글**
    - 계층형 댓글 구조
    - 소프트 삭제 지원
- ✅ **Redis 캐싱**
    - 도메인별 TTL 설정
    - 캐시 무효화 전략
- ✅ **배치 처리**
    - Spring Batch로 인기 게시글 집계
    - 오래된 게시글 아카이빙
- ✅ **비동기 처리**
    - 이벤트 기반 알림 시스템

---

## 3. 성능 최적화
- **N+1 문제 해결**
    - `EntityGraph`, `Fetch Join` 활용
- **벌크 연산**
    - 조회수 증가 등 일괄 처리
- **낙관적 락**
    - 동시성 제어
- **QueryDSL**
    - 동적 쿼리 최적화
- **인덱스 설계**
    - 검색 성능 향상

---

## 4. 보안
- **Spring Security + JWT**
    - 무상태 인증
- **CORS 설정**
    - 화이트리스트 방식
- **비밀번호 암호화**
    - `BCrypt` 사용
- **시큐어 코딩**
    - SQL Injection 방어
    - XSS 방어

---

## 5. 확장성 & 유지보수
- **글로벌 예외 처리**
    - `@ControllerAdvice`
- **공통 API 응답 객체**
    - 일관된 응답 형식
- **Swagger 문서화**
    - API 자동 문서화
- **테스트 코드**
    - 단위 테스트 + 통합 테스트
- **Docker/K8s 대응**
    - 환경변수 기반 설정

---

# 면접 예상 질문 & 답변 포인트

### ❓ JWT vs Session 선택 이유?
- 무상태 서버로 **수평 확장 용이**
- **MSA 환경**에서 인증 정보 공유 편리

---

### ❓ Redis 캐시 전략?
- **Cache-Aside 패턴** 적용
- 도메인별 **TTL 차별화**
    - 회원: 1시간
    - 게시글: 30분

---

### ❓ N+1 문제 해결 방법?
- 기본 **LAZY 로딩**
- 필요 시 `Fetch Join`, `EntityGraph` 활용

---

### ❓ 대규모 트래픽 대응?
- **Redis 캐싱**으로 DB 부하 감소
- **비동기 처리**로 응답 속도 개선
- **인덱스 최적화**로 조회 성능 향상

---

### ❓ 트랜잭션 관리 전략?
- 서비스 메서드 단위 `@Transactional`
- 조회 전용은 `readOnly = true`
- 외부 API 호출은 **트랜잭션 외부**에서 처리
